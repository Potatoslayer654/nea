import tkinter as tk
from tkinter import ttk
import random
CELL_SIZE = 50      # size of each grid cell in pixels
colour_list = []    
colours = ["#F9E4BC", '#895129'] # colours for the board
locked_tiles = [] # tiles what cannot move 
board_tile_location = [] # location of all tiles on the 15x15 board
colours_hand = ["#1E90FF","#6495ED","#4863A0","#79BAEC",'#95B9C7', '#36454F'] # colours for the hand labels
score = {letter: score for letter, score in zip(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ", [1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10])}


class ClassToStoreReturnedVariable:
    def __init__ (self):
        self.frozen = False
        self.tile_bag = (
        ["A"] * 9 + ["B"] * 2 + ["C"] * 2 + ["D"] * 4 + ["E"] * 12 +
        ["F"] * 2 + ["G"] * 3 + ["H"] * 2 + ["I"] * 9 + ["J"] * 1 +
        ["K"] * 1 + ["L"] * 4 + ["M"] * 2 + ["N"] * 6 + ["O"] * 8 +
        ["P"] * 2 + ["Q"] * 1 + ["R"] * 6 + ["S"] * 4 + ["T"] * 6 +
        ["U"] * 4 + ["V"] * 2 + ["W"] * 2 + ["X"] * 1 + ["Y"] * 2 + ["Z"] * 1 + ["blank"] * 2)
        self.tile_bag_amount = 100
        self.green_grids = []
        self.banned_tiles = []
        self.grid_locations =[]
        self.current_locations = []
    def setFrozen (self, x):
        self.frozen = x
    def getFrozen (self):
        return self.frozen
    def setTilebag(self,x):
        self.tile_bag = x
    def getTilebag(self):
        return self.tile_bag
    def setTilebagamount(self,x):
        self.tile_bag_amount = x
    def getTilebagamount(self):
        return self.tile_bag_amount
    def setGreen_grids(self,x):
        self.green_grids = x
    def getGreen_grids(self):
        return self.green_grids
    def setBanned_tiles(self,x):
        self.banned_tiles = x
    def getBanned_tiles(self):
        return self.banned_tiles
    def setGrid_location(self,x):
        self.grid_locations = x
    def getGrid_location(self):
        return self.grid_locations
    def setCurrent_location(self,x):
        self.current_locations = x
    def getCurrent_location(self):
        return self.current_locations





variable = ClassToStoreReturnedVariable()

#This function will allow users be able to make Tiles green with the mouse 2 button to be able to swap them for other tiles
def greening_grids(event):
    #get the attribute from the class storing green grids and the frozen variable as well
    green_grids = variable.getGreen_grids()
    frozen = variable.getFrozen()
    
    #set the current tile equal to widget 
    widget = event.widget
    
    #get the row and col info of the tile which wants to be highlighted green
    row = widget.grid_info()['row']
    col = widget.grid_info()['column']
    
    #make it into a tuple
    tup = (row,col)
    
    #get the colour of the tile
    colour = widget.cget("background")
    
    #check if the tiles are on the are in the users hand ( row 15 ) , the tile is not already highlighted
    #and also check if the game is not frozen to be able to change the colour of the tile to green
    if row == 15 and colour != "green" and frozen == False:
        
        #set the colour of the Tile to green
        widget.config(background = "green")
        
        #add the position of this green tile to the green_grid list
        green_grids.append((tup))
        
    #set the attribute Green_grids as the green_grids list 
    variable.setGreen_grids(green_grids)


#This function will allow the user to be able to turn a green Tile back into a white one with the mouse 3 button(Scroll wheel button)
def bleaching_grids(event):
    #get the attribute from the class called green_grids and also get the frozen attribute
    green_grids = variable.getGreen_grids()
    frozen = variable.getFrozen()
    
    #set the the current tile equal to widget 
    widget = event.widget
    
    #Get the row and col info of the Tile 
    row = widget.grid_info()['row']
    col = widget.grid_info()['column']
    
    #Make a Tuple of the row and col
    tup = (row,col)
    
    #Check if the Tile is in the users hand , check if the tile is already green
    #and check if the game is not frozen 
    if row == 15 and tup in green_grids and frozen == False:
        
        #Set the colour of the tile back to white 
        widget.config(background = "white")
        
        #Remove that the tile from the green_grids list as it is no longer green
        green_grids.remove((tup))
    
    #Set the attribute of green_grids to the list 
    variable.setGreen_grids(green_grids)
    
#This function will check around The tile placed and if that move is legal 
def check_around_tile(row,col):
    #Get the attributes for both grid_locations and current_locations
    grid_locations = variable.getGrid_location()
    current_locations = variable.getCurrent_location()
    
    #check if all the current tiles are in one row or col
    for i in current_locations:
        if i[0] != row and i[1] != col:
            if len(current_locations) >1:
                return False
    #Will only store the positions in grid_locations which are part of the board and not the hand 
    board_locations = [x for x in grid_locations if x[0] != 15]
    
    #Will not check around the tile if its the first move 
    if len(board_locations) == 1:
        return True
    #Set at false as if no condition is met it means there are no tiles around it
    checker = False
    #check below it
    if row != 0:
        for widget in window.grid_slaves(row-1,col):
            if isinstance(widget, tk.Label):
                checker = True
    #check above it 
    if row != 14:
        for widget in window.grid_slaves(row+1,col):
            if isinstance(widget, tk.Label):
                checker = True
    #check to the left of it 
    if col != 0:
        for widget in window.grid_slaves(row,col-1):
            if isinstance(widget, tk.Label):
                checker = True
    #check to the right of it 
    if col != 14:
        for widget in window.grid_slaves(row,col+1):
            if isinstance(widget, tk.Label):
                checker = True
    #sends back if the move is legal or not 
    return checker
    


#This function will store and calculate the inital x,y and row,col values of the Tile being moved
def drag_start(event):
    widget = event.widget
    
    #Stores the initial x and y coords of the tile 
    widget.startX = event.x
    widget.startY = event.y
    
    #Stores the initial row and col of the tile 
    widget.original_row = widget.grid_info()['row']
    widget.original_column = widget.grid_info()['column']


#This will keep the Tile stuck to the mouse while the mouse 1 button is being held
def drag_motion(event):
    widget = event.widget
    
    #Calculates the current position of the Tile in terms of (x,y) 
    x = widget.winfo_x() - widget.startX + event.x
    y = widget.winfo_y() - widget.startY + event.y
    
    #This will keep the widget to change and stay with the Pointer on screen
    widget.place(width=CELL_SIZE, height=CELL_SIZE,x=x, y=y)



def drop(event):
    #Call the Attribures Grid_Locations and Current_Locations and frozen
    grid_locations = variable.getGrid_location()
    current_locations = variable.getCurrent_location()
    frozen = variable.getFrozen()

    widget = event.widget
    
    #get the colour of the tile
    colour = widget.cget("background")
    
    #calculate the new row and new col of the Tile based on the the position of it in the screen 
    new_row = (widget.winfo_y() + CELL_SIZE // 2) // CELL_SIZE
    new_col = (widget.winfo_x() + CELL_SIZE // 2) // CELL_SIZE
    
    #Create a tuple storing the new postition of the Tile 
    new_tuple=(new_row,new_col)
    
    #Create a tuple storing the old position of the tile 
    org_tuple = (widget.original_row,widget.original_column)
    
    # Limit to a specific grid size (15x15)
    #check if the new position is not already taken by already being in grid_position
    #check if the initial position is a locked tile
    if org_tuple not in locked_tiles and 0 <= new_row < 15 and 0 <= new_col < 15 and  new_tuple not in grid_locations :
        
                #set it to the new location in the grid 
                widget.grid(row=new_row, column=new_col, sticky="nsew")
                
                #add the new tile to the grid_location list
                grid_locations.append(new_tuple)
                
                #remove the old tile from the grid_location list
                grid_locations.remove(org_tuple)
                
                #remove the location of the tile previous to this move in the list
                if (org_tuple) in current_locations:
                    current_locations.remove(org_tuple)
                    
                #add the location of the new tile into current_locations
                current_locations.append((new_row,new_col))
                
                #Store the result of checking around the tile to see if the move is legal
                result = check_around_tile(new_row,new_col)
                
                #Check if the starting tile has been placed and prevent any tiles being placed until it has been placed
                #it also will check if the the game should be frozen
                #Also check if the tile is legal by calling the check around function
                if (7,7) not in grid_locations or frozen == True or result == False:
                    #As the move is illegal the tile will be send back to its original postion
                    widget.grid(row=widget.original_row, column=widget.original_column, sticky="nsew")
                    
                    #Add the Original Position back into the grid_location list as the tile goes back to that position
                    grid_locations.append(org_tuple)
                    #Remove the New position in the grid_location list as it has gone back to its original poistion 
                    grid_locations.remove(new_tuple)
                    #Add this location to current locations as it is a new location within the same turn 
                    current_locations.remove(new_tuple)
                    

                            


    #check if the tile is being moved into the hand
    #checking if the location is taken and sending it back if it is
    #checks if the tile is not locked 
    elif org_tuple not in locked_tiles and new_row == 15 and 3 <= new_col <=9 and new_tuple not in grid_locations:
                #Place the tile into the new position (which would be the one of the grids which are part of the users hand)
                widget.grid(row=new_row, column=new_col, sticky="nsew")
                
                #Add the New position into the grid_location list 
                grid_locations.append(new_tuple)
                
                #Remove the old Position of the tile from grid_location list as it is not longer in that position 
                grid_locations.remove(org_tuple)
                
                #check if the old position was a current tile and remove it if it was 
                if (org_tuple) in current_locations:
                            current_locations.remove(org_tuple)
    #send back to the original position if any requirment is not met
    else:
        widget.grid(row=widget.original_row, column=widget.original_column, sticky="nsew")
        
    #Set the the new grid_location and current_location 
    variable.setGrid_location(grid_locations)
    variable.setCurrent_location(current_locations)


def end_turn(): 
    #check the location of each tile within grid_locaitons
    for i in grid_locations:
        
        #Check if that tile is not part of the users hand (any tile in row 15)
        #check if it is not already in the board_tile_location
        if i[0] != 15 and i not in board_tile_location:
            
            #add this postion to the variable board_tile_location
            board_tile_location.append(i)
            
    #look at each location in board_tile_location
    for i in board_tile_location:
        
        #if its not already in locked tiles add that postion into locked_tiles
        if i not in locked_tiles:
            locked_tiles.append(i)
            
    #The turn has ended so the user should be frozen so set the attribure frozen to True
    x = True
    variable.setFrozen(x)
    
    #the turn has ended so current_location should be reset
    current_locations = []
    variable.setCurrent_location(current_locations)
    
    #call the check_hand() function to be able to re fill the users hand 
    check_hand()





def create_tile(empty_grid):
    grid_locations = variable.getGrid_location()

    local_tile_bag_amount = variable.getTilebagamount()
    local_tile_bag = variable.getTilebag()

    #randomly get a letter from the tile back and delete from the tile bag
    num = random.randint(0,local_tile_bag_amount-1)
    local_tile_bag_amount = local_tile_bag_amount - 1



    letter = local_tile_bag.pop(num-1)
    
    #create the tile with the specified Letter
    tile = tk.Label(window, text=letter, background="white", anchor='center')
    tile.place(width=CELL_SIZE, height=CELL_SIZE)
     

    tile.grid(row =empty_grid[0],column=empty_grid[1], sticky="nsew",pady=5, padx=5)
    tile_tuple = (empty_grid)
    grid_locations.append(tile_tuple)
    print(grid_locations)

    variable.setTilebagamount(local_tile_bag_amount)
    variable.setTilebag(local_tile_bag)

    

    tile.bind("<Button-1>", drag_start )
    tile.bind("<B1-Motion>", drag_motion)
    tile.bind("<ButtonRelease-1>", drop)
    tile.bind("<Button-3>",greening_grids)
    tile.bind("<Button-2>",bleaching_grids)

    variable.setGrid_location(grid_locations)



def check_hand():
    grid_locations = variable.getGrid_location()
    x = variable.getTilebagamount()
    for i in range(3,10):
            empty_grid = (15,i)
            if empty_grid not in grid_locations:
                if x == 0:
                    print("tile bag empty")
                else:
                    create_tile(empty_grid)



def start_game():
    for i in range(3,10):
            empty_grid = (15,i)
            create_tile(empty_grid)

def unfreeze():
    x = False
    variable.setFrozen(x)     


def skip():
    grid_locations = variable.getGrid_location()
    for i in (3,9):
        if (15,i) not in grid_locations:
            print("Cannot skip as tiles are on the board")
            break
        else:
            x = True
            variable.setFrozen(x)


def swap():
    green_grids = variable.getGreen_grids()
    local_tile_bag_amount = variable.getTilebagamount()
    local_tile_bag = variable.getTilebag()
    fixed = green_grids.copy()
    if len(green_grids) != 0:
        variable.setFrozen(True)

    for i in fixed:
        row = i[0]
        col = i[1]
        for widget in window.grid_slaves(row,col):
            if isinstance(widget, tk.Label):
                letter = widget.cget("text")
                local_tile_bag.append(letter)
                local_tile_bag_amount = local_tile_bag_amount + 1

                num = random.randint(0,local_tile_bag_amount-1)
                local_tile_bag_amount = local_tile_bag_amount - 1

                letter = local_tile_bag.pop(num-1)

                widget.config(text = letter)

                widget.config(background = "white")
                green_grids.remove((row,col))

    variable.setGreen_grids(green_grids)
    variable.setTilebag(local_tile_bag)
    variable.setTilebagamount(local_tile_bag_amount)


                






window = tk.Tk()
window.title("Grid")
window.geometry("750x800")

print(window.winfo_screenwidth())

# Configure the grid to have fixed cell sizes
for i in range(16): # Set minimum size for columns
    window.rowconfigure(i, weight=1, minsize=CELL_SIZE) # Set minimum size for rows
for i in range(15):
    window.columnconfigure(i, weight=1, minsize=CELL_SIZE)   # Set minimum size for columns


#Create Background colour for the grid
frame = tk.Frame(window, bg=random.choice(colours))
frame.place(width=CELL_SIZE, height=CELL_SIZE) 
for i in range(15):
    for j in range(15):
        bg = random.choice(colours)
        if len(colour_list) != 0:
            while bg == colour_list[-1]:
                bg = random.choice(colours)
            if len(colour_list) > 15:
                while bg == colour_list[-15]:
                    bg = random.choice(colours)



        colour_list.append(bg)
        frame = tk.Frame(window, bg=bg)

        frame.place(width=CELL_SIZE, height=CELL_SIZE)
        if i == 7 and j == 7:
            frame = tk.Frame(window, bg="black")
            frame.grid(row=i, column=j, sticky="nsew")
        else:
            frame.grid(row=i, column=j, sticky="nsew")

#create hand

swap_button = ttk.Button(window, text="Swap",command = swap)
swap_button.place(width=CELL_SIZE, height=CELL_SIZE)
swap_button.grid(row=15 , column=0 , sticky="nsew")

skip_button = ttk.Button(window , text="Skip",command =skip)
skip_button.place(width=CELL_SIZE, height=CELL_SIZE)
skip_button.grid(row=15 , column=1 , sticky="nsew")

                      
#this button will call the end_turn function
play_button = tk.Button(window , text="Finish",bg='white',command = end_turn)
play_button.place(width=CELL_SIZE, height=CELL_SIZE)
play_button.grid(row=15 , column=14 , sticky="nsew")


freeze_button = ttk.Button(window , text="unfreeze",command = unfreeze)
freeze_button.place(width=CELL_SIZE, height=CELL_SIZE)
freeze_button.grid(row=15 , column=13 , sticky="nsew")


#create the labels for the users hand 
for j in range(3,10):
        frame = tk.Frame(window, bg=colours_hand[j-4] ,)
        frame.place(width=CELL_SIZE, height=CELL_SIZE) 
        frame.grid(row=15, column=j, sticky="nsew")


start_game()


window.mainloop()
